// notify.min.js, for SugarCube 2, by Chapel
// v1.1.1, 2024-07-22, 336675ff2cabe5f729a5f30d86aa409cc8432726
; !function () { var s = /\d+m?s$/; function a(s, a, e) { "string" == typeof s && ("number" != typeof a && (a = !1), $(document).trigger({ type: ":notify", message: s, delay: a, class: e || "" })) } $(document.body).append("<div id='notify'></div>"), $(document).on(":notify", (function (s) { s.message && "string" == typeof s.message && (s.message.trim(), s.class ? "string" == typeof s.class ? s.class = "open macro-notify " + s.class : Array.isArray(s.class) ? s.class = "open macro-notify " + s.class.join(" ") : s.class = "open macro-notify" : s.class = "open macro-notify", s.delay ? ("number" != typeof s.delay && (s.delay = Number(s.delay)), Number.isNaN(s.delay) && (s.delay = 2e3)) : s.delay = 2e3, $("#notify").empty().wiki(s.message).addClass(s.class), setTimeout((function () { $("#notify").removeClass() }), s.delay)) })), Macro.add("notify", { tags: null, handler: function () { var e = this.payload[0].contents, t = !1, i = !1; if (this.args.length > 0) { var n = s.test(this.args[0]); "number" == typeof this.args[0] || n ? (t = n ? Util.fromCssTime(this.args[0]) : this.args[0], i = this.args.length > 1 && this.args.slice(1).flat(1 / 0)) : i = this.args.flat(1 / 0).join(" ") } a(e, t, i) } }), setup.notify = a }();
// end notify.min.js
// dialog-api-macro-set.min.js, for SugarCube 2, by Chapel
// v1.3.0, 2024-07-22, 336675ff2cabe5f729a5f30d86aa409cc8432726
; Macro.add("dialog", { tags: ["onopen", "onclose"], handler: function () { var t = "", s = null, o = null, n = this.args.length > 0 ? this.args[0] : "", i = this.args.length > 1 ? this.args.slice(1).flat(1 / 0) : []; this.payload.forEach((function (n, i) { 0 === i ? t = n.contents : "onopen" === n.name ? s = s ? s + n.contents : n.contents : o = o ? o + n.contents : n.contents })), i.push("macro-" + this.name), Dialog.setup(n, i.join(" ")), Dialog.wiki(t), s && "string" == typeof s && s.trim() && $(document).one(":dialogopened", (function () { $.wiki(s) })), o && "string" == typeof o && o.trim() && $(document).one(":dialogclosed", (function () { $.wiki(o) })), Dialog.open() } }), Macro.add("popup", { handler: function () { if (this.args.length < 1) return this.error("need at least one argument; the passage to display"); if (!Story.has(this.args[0])) return this.error("the passage " + this.args[0] + "does not exist"); var t = this.args[0], s = this.args.length > 1 ? this.args[1] : "", o = this.args.length > 2 ? this.args.slice(2).flat(1 / 0) : []; o.push("macro-" + this.name), Dialog.setup(s, o.join(" ")), Dialog.wiki(Story.get(t).processText()), Dialog.open() } }), Macro.add("dialogclose", { skipArgs: !0, handler: function () { Dialog.close() } });
// end dialog-api-macro-set.min.js


// 投骰子
/* Random Utils, By BlackStar, Ver.0.2.3 */
(() => { let w = () => (State.variables.ENABLE_SEED_RANDOM ? _raw_seedrandom : Math.random)(); var r = (r, a) => Math.floor(w() * (a - r + 1)) + r; let a = (r, a) => { var o = a.reduce((r, a) => r + a, 0); if (1e-8 < Math.abs(o - 1)) throw new Error("Total probability does not sum to 1"); var t, n = []; let e = 0; for (t of a) e += t, n.push(e); let d = w(); return r[n.findIndex(r => r > d)] }; var o = r => a(Object.keys(r), Object.values(r)), t = r => a(Array.from(r.keys()), Array.from(r.values())); setup.drawOptionByMap = t, window.drawOptionByMap = window.drawOptionByMap || t, setup.drawOption = o, window.drawOption = window.drawOption || o, setup.randomInt = r, window.randomInt = window.randomInt || r })();
/* End Random Utils */

/* Macro Utils, By BlackStar, Partially adapted from ChapelR, Ver.0.4.0 */
(() => { const isValidVariable = varName => varName && typeof varName === "string" && varName.length >= 2 && (varName[0] === "$" || varName[0] === "_"); const repeat = (times, action) => { for (let i = 0; i < times; i++) { action(i) } }; const incVar = (v, inc = 1) => State.setVar(v, (State.getVar(v) ?? 0) + inc); const WikiVars = (pairs, entity) => { const shadowStore = {}; for (const [varName, value] of Object.entries(pairs)) { if (Object.hasOwn(State.temporary, varName)) { shadowStore[`_${varName}`] = State.temporary[varName] } State.temporary[varName] = value; entity.addShadow(`_${varName}`); if (Object.hasOwn(State.variables, varName)) { shadowStore[`$${varName}`] = State.variables[varName] } State.variables[varName] = State.temporary[varName]; entity.addShadow(`$${varName}`) } try { new Wikifier(entity.output, entity?.payload?.[0]?.contents || "") } finally { for (const [varName] of Object.entries(pairs)) { if (Object.hasOwn(shadowStore, `_${varName}`)) { State.temporary[varName] = shadowStore[`_${varName}`] } else { delete State.temporary[varName] } if (Object.hasOwn(shadowStore, `$${varName}`)) { State.variables[varName] = shadowStore[`$${varName}`] } else { delete State.variables[varName] } } } }; const applyBounds = (value, min, max) => { if (min === undefined && max === undefined) { return value } if (max === undefined) { return Math.max(min, value) } if (min === undefined) { return Math.min(max, value) } return Math.max(min, Math.min(max, value)) }; const convertToArray = input => { const array = []; for (const [key, value] of Object.entries(input)) { array.push(key, value) } return array }; const convertToObject = arr => { if (!Array.isArray(arr) || arr.length === 0) { return {} } const flatten = array => array.reduce(((flatArr, item) => flatArr.concat(Array.isArray(item) ? flatten(item) : item)), []); const flattened = flatten(arr); const obj = {}; for (let i = 0; i < flattened.length; i += 2) { const key = flattened[i]; if (typeof key === "string") { obj[key] = flattened[i + 1] } } return obj }; const sortBy = (arr, field, order = "asc") => { const lowerCaseOrder = order.toLowerCase(); if (lowerCaseOrder !== "asc" && lowerCaseOrder !== "desc") { throw new Error(`Invalid order: ${order}. Use 'asc' or 'desc'.`) } return arr.sort(((a, b) => { if (!(field in a) || !(field in b)) { throw new Error(`Field '${field}' does not exist in one of the objects.`) } const fieldA = a[field]; const fieldB = b[field]; if (Array.isArray(fieldA) && Array.isArray(fieldB)) { return lowerCaseOrder === "asc" ? fieldA.length - fieldB.length : fieldB.length - fieldA.length } if (typeof fieldA === "object" && typeof fieldB === "object") { if (fieldA instanceof Date && fieldB instanceof Date) { return lowerCaseOrder === "asc" ? fieldA.getTime() - fieldB.getTime() : fieldB.getTime() - fieldA.getTime() } else if (fieldA instanceof Map && fieldB instanceof Map) { return lowerCaseOrder === "asc" ? fieldA.size - fieldB.size : fieldB.size - fieldA.size } return 0 } if (typeof fieldA === "string" && typeof fieldB === "string") { return lowerCaseOrder === "asc" ? fieldA.localeCompare(fieldB) : fieldB.localeCompare(fieldA) } if (typeof fieldA === "number" && typeof fieldB === "number") { return lowerCaseOrder === "asc" ? fieldA - fieldB : fieldB - fieldA } return 0 })) }; setup.sortBy = sortBy; window.sortBy = window.sortBy || sortBy; setup.convertToObject = convertToObject; window.convertToObject = window.convertToObject || convertToObject; setup.convertToArray = convertToArray; window.convertToArray = window.convertToArray || convertToArray; setup.applyBounds = applyBounds; window.applyBounds = window.applyBounds || applyBounds; setup.repeat = repeat; window.repeat = window.repeat || repeat; setup.isValidVariable = isValidVariable; window.isValidVariable = window.isValidVariable || isValidVariable; setup.WikiVars = WikiVars; window.WikiVars = window.WikiVars || WikiVars; setup.incVar = incVar; window.incVar = window.incVar || incVar })();
/* End Macro Utils */

/* Expr Parser, By BlackStar, Ver.0.2.0 */
(() => { const parseExpr = expr => { const match = expr.match(/(\d*)[dD](\d+)/); if (!match) return 0; const num = parseInt(match[1], 10) || 1; const dice = parseInt(match[2], 10); return Array.from({ length: num }).map((() => randomInt(1, dice))) }; const rollWithDetails = expr => { const diceRolls = []; const replaced = expr.replace(/(\d*[dD]\d+)/g, (match => { const rolls = parseExpr(match); diceRolls.push(...rolls); return rolls.reduce(((sum, roll) => sum + roll), 0) })); return [eval(replaced), diceRolls] }; const rollDice = expr => rollWithDetails(expr)[0]; Macro.add("evelexpr", { tags: null, handler() { if (this.args.length === 0) { return this.error("No provide expr") } const expr = this.args[0]; if (typeof expr !== "string") { return this.error("Please provide string") } const [result, rolls] = rollWithDetails(expr); WikiVars({ result: result, rolls: rolls }, this) } }); setup.rollDice = rollDice; window.rollDice = window.rollDice || rollDice })();
/* End Expr Parser */
// 骰子结束
